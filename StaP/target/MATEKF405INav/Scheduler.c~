#include "MainLoop.h"
#include "AlphaPilot.h"
#include "Logging.h"
#include "M24XX.h"
#include "Console.h"
#include "BaseI2C.h"
#include "NVState.h"
#include "MS4525.h"
#include "Command.h"
#include "Sensor.h"
#include <string.h>
#include <ctype.h>

//
// Datagram protocol integration
//

#define MAX_DG_SIZE (1<<9)
#define TX_TIMEOUT  5 // Milliseconds

DgLink_t hostLink, alphaLink, telemLink;
uint8_t datagramRxStoreHost[MAX_DG_SIZE], datagramRxStoreAlphaLink[MAX_DG_SIZE], datagramRxStoreTelemLink[MAX_DG_SIZE];

typedef struct {
  const char *name;
  uint8_t stap;
} Context_t;

Context_t context[] = { {"HOST", STAP_LINK_HOSTTX }, {"AL", STAP_LINK_ALINKTX }, {"TELEM", STAP_LINK_TELEMTX } };

void datagramRxError(void *cp, const char *error, uint16_t code)
{
  Context_t *context = (Context_t*) cp;
  consoleNote_P(CS_STRING("["));
  consolePrint(context->name);
  consolePrint_P(CS_STRING("] "));
  consolePrint(error);
  consolePrint_P(CS_STRING(" ("));
  consolePrintUI(code);
  consolePrintLn(")");
}
  
void datagramHandlerHost(void *cp, uint8_t node, const uint8_t *data, size_t size)
{
  Context_t *context = (Context_t*) cp;
  uint8_t header = data[0];

  data++;
  size--;
  
  switch(header) {
  case HL_HEARTBEAT:
    //    consoleNoteLn_P(CS_STRING("HEARTBEAT"));

    if(context->stap == STAP_LINK_HOSTTX && !vpStatus.consoleLink) {
      consoleNoteLn_P(CS_STRING("Console CONNECTED"));
      vpStatus.consoleLink = true;
    }
    break;
    
  case HL_CONSOLE:
    if(context->stap == STAP_LINK_HOSTTX)
      executeCommand((char*) data);
    break;

  case HL_SIMLINK:
    if(context->stap == STAP_LINK_HOSTTX
       && vpStatus.consoleLink && size == sizeof(sensorData)) {
      if(!vpStatus.simulatorLink) {
	consoleNoteLn_P(CS_STRING("Simulator CONNECTED"));
	vpStatus.simulatorLink = true;
      }

      memcpy(&sensorData, data, sizeof(sensorData));
      simTimeStamp = vpTimeSecsApprox;
      simFrames++;
    }
    break;

  case HL_PING:
    break;

  default:
    datagramRxError(cp, "FUNNY", header);
  }
}

void datagramHandlerTelemLink(void *context, uint8_t node, const uint8_t *data, size_t size)
{
  
}

void datagramHandlerAlphaLink(void *context, uint8_t node, const uint8_t *data, size_t size)
{
  sensorDataReceive(node & ~1, node & 1, data, size);
}

void dgLinkTxBegin(void *cp)
{
  return;
#ifdef STAP_LinkTxBegin
  Context_t *context = (Context_t*) cp;
  if(context->stap != STAP_LINK_HOSTTX || vpStatus.consoleLink)
    STAP_LinkTxBegin(context->stap);
#endif
}

void dgLinkTxEnd(void *cp)
{
#ifdef STAP_LinkTxEnd
  Context_t *context = (Context_t*) cp;
  if(context->stap != STAP_LINK_HOSTTX || vpStatus.consoleLink)
    STAP_LinkTxEnd(context->stap);
#endif
}

void dgLinkOut(void *cp, const uint8_t *b, size_t l)
{
  Context_t *context = (Context_t*) cp;
  if(context->stap != STAP_LINK_HOSTTX || vpStatus.consoleLink)
    STAP_LinkPut(context->stap, (const char*) b, l, TX_TIMEOUT);
}

//
// Scheduler
//

struct Task *currentTask;

static bool scheduler(void)
{
  bool status = false;
  int i = 0;
    
  //  consoleNote("S ");

  while(alphaPilotTasks[i].code) {
    bool signal = false;
    
    vpTimeAcquire();
    signalUpdateAge();

    VP_TIME_MICROS_T elapsed
      = VP_ELAPSED_MICROS(alphaPilotTasks[i].lastInvoked);

    if((alphaPilotTasks[i].period && elapsed >= alphaPilotTasks[i].period) || (signal = signalReceive(alphaPilotTasks[i].signal))) {
      if(!signal && alphaPilotTasks[i].realTime
	 && elapsed < 4*alphaPilotTasks[i].period/3)
	// A realtime task that has not slipped that much, try to catch up
	alphaPilotTasks[i].lastInvoked += alphaPilotTasks[i].period;
      else {
 	// Either not a realtime task or we're slipping too much
	alphaPilotTasks[i].lastInvoked = vpTimeMicrosApprox;
#ifdef ALP_PROFILING
	if(!signal)
	  alphaPilotTasks[i].lagged++;
#endif
      }

      currentTask = &alphaPilotTasks[i];
      
#ifdef ALP_PROFILING
      VP_TIME_MICROS_T startTime = vpTimeMicrosApprox;
#endif      

      alphaPilotTasks[i].code();
      
#ifdef ALP_PROFILING
      alphaPilotTasks[i].timesRun++;
      
      if(signal)
	alphaPilotTasks[i].triggered++;
      
      if(vpStatus.consoleLink) 
	alphaPilotTasks[i].runTime += vpTimeMicros() - startTime;
#endif      
      status = true; // We had something to do
    }
    
    //    task++;
    i++;
  }

  //  consoleNote("SX ");
  
  currentTask = NULL;
  return status;
}

void schedulerReport(void)
{
#ifdef ALP_PROFILING
  static VP_TIME_MICROS_T lastReport;
  VP_TIME_MICROS_T period = vpTimeMicros() - lastReport;
  float load = 0.0f, cum = 0.0f;
  int i = 0;  
      
  consoleNoteLn_P(CS_STRING("Task statistics"));

  for(i = 0; alphaPilotTasks[i].code != NULL; i++) {
    consoleNote("  ");
    consolePrintI(i);
    consoleTab(10);
    consolePrintF(alphaPilotTasks[i].timesRun / (period / 1.0e6));
    consolePrint_P(CS_STRING(" Hz "));
    load = 100.0f * alphaPilotTasks[i].runTime / period;
    cum += load;
    consoleTab(20);
    consolePrintF(load);
    consolePrint_P(CS_STRING(" %"));
    consoleTab(30);
    if(alphaPilotTasks[i].signal != sig_invalid) {
      consolePrintF((float) alphaPilotTasks[i].triggered / (period / 1.0e6));
      consolePrint_P(CS_STRING(" Hz "));
    }
    consoleTab(40);
    if(alphaPilotTasks[i].realTime) {
      consolePrintF((float) alphaPilotTasks[i].lagged / (period / 1.0e6));
      consolePrint_P(CS_STRING(" Hz "));
    }
    consoleNL();
    alphaPilotTasks[i].timesRun = 0;
    alphaPilotTasks[i].lagged = 0;
    alphaPilotTasks[i].triggered = 0;
    alphaPilotTasks[i].runTime = 0;
  }

  consoleTab(20);
  consolePrintF(cum);
  consolePrintLn(" %");

  lastReport = vpTimeMicros();
#endif  

  consoleNote_P(CS_STRING("Uptime "));
  consolePrintUL(uptimeMinutes);
  consolePrintLn_P(CS_STRING(" minutes"));
}

//
// Host comms test loop
//

void hostLoopback(void)
{
  if(STAP_LinkStatus(STAP_LINK_HOSTRX) > 0)
    STAP_LinkPutChar(STAP_LINK_HOSTTX,
		     toupper(STAP_LinkGetChar(STAP_LINK_HOSTRX)), TX_TIMEOUT);
}

//
// Setup and main loop
//

void mainLoopSetup()
{
#ifdef GNDTEST
  vpStatus.consoleLink = true;
#else
  vpStatus.consoleLink = false;
#endif

  vpStatus.consoleLink = true;
  
  stap_initialize();

  datagramLinkInit(&hostLink, 0,
		   datagramRxStoreHost, MAX_DG_SIZE,
		   (void*) &context[0],
		   datagramHandlerHost,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);

  datagramLinkInit(&alphaLink, 0,
		   datagramRxStoreAlphaLink, MAX_DG_SIZE,
		   (void*) &context[1],
		   datagramHandlerAlphaLink,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);

  /*
  datagramLinkInit(&telemLink, 0,
		   datagramRxStoreTelemLink, MAX_DG_SIZE,
		   (void*) &context[2],
		   datagramHandlerTelemLink,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);
  */

  consoleNoteLn_P(CS_STRING("Project | Alpha"));   

  // Initial gear state is DOWN
  
  vpControl.gearSel = 0;
  vpMode.gearSelected = false;

  // Initialization task state

  vpControl.initState = it_init;
  
  // Done
  
  consoleNoteLn_P(CS_STRING("Initialized."));
}

VPPeriodicTimer_t minuteTimer = VP_PERIODIC_TIMER_CONS(60.0e3);

void mainLoop() 
{
  bool idling = false;
  VP_TIME_MICROS_T idleStarted = 0, idleEnded = 0;

  while(true) {
    idleEnded = vpTimeMicros();

    if(vpPeriodicEvent(&minuteTimer)) {
      uptimeMinutes++;

      if(uptimeMinutes % 5 == 0) {
	consoleNote_P(CS_STRING("Uptime "));
	consolePrintUL(uptimeMinutes);
	consolePrintLn_P(CS_STRING(" minutes"));
	consoleFlush();
      }
    }

    if(scheduler()) {    
      // Had something to do
      if(idling) {
	// Not idling anymore
	idleMicros += idleEnded - idleStarted;
	idling = false;
      }
    } else if(!idling) {
      // Just started idling
      idling = true;
      
      if(vpControl.initState == it_done && !logReady(false))
	logInitialize(50);

      idleStarted = vpTimeMicros();
    }
}
}
