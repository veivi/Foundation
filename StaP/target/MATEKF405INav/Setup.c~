#include <string.h>
#include <ctype.h>
#include "AlphaPilot.h"
#include "Setup.h"
#include "Objects.h"
#include "Console.h"
#include "Sensor.h"

//
// Datagram protocol integration
//

#define MAX_DG_SIZE          (3<<5)
#define TX_TIMEOUT           1000 // Milliseconds
#define SERIAL_BUFSIZE       (1<<6)

DgLink_t telemLink, hostLink, alphaLink, alphaLinkMonitor;
uint8_t datagramRxStoreHost[MAX_DG_SIZE], datagramRxStoreAlphaLink[MAX_DG_SIZE], datagramRxStoreAlphaLinkMonitor[MAX_DG_SIZE], datagramRxStoreTelemLink[MAX_DG_SIZE];

char alphaRxBuffer[SERIAL_BUFSIZE];
char recARxBuffer[SERIAL_BUFSIZE], recBRxBuffer[SERIAL_BUFSIZE];
char alphaTxBuffer[SERIAL_BUFSIZE], alphaMonBuffer[SERIAL_BUFSIZE];
char telemTxBuffer[SERIAL_BUFSIZE], telemRxBuffer[SERIAL_BUFSIZE];
char hostTxBuffer[SERIAL_BUFSIZE], hostRxBuffer[SERIAL_BUFSIZE];

/*
#define STAP_UART_VCP             0
#define STAP_UART_TELEM           1
// #define STAP_UART_SRXLINA        2
#define STAP_UART_SRXLBUSA        2
#define STAP_UART_SRXLINB         4
#define STAP_UART_SRXLOUTA        3
#define STAP_UART_SRXLOUTB        5
#define STAP_UART_ALINK           6
*/

StaP_LinkRecord_T StaP_LinkTable[StaP_NumOfLinks] = {
  /*  [ALP_Link_ALinkRX] = { 1, AL_BITRATE, LINK_MODE_RX,
			 VPBUFFER_CONS(alphaRxBuffer), ALP_Sig_AlphaRX, 5 },
  [ALP_Link_ALinkMon] = { 2, AL_BITRATE, LINK_MODE_TX,
			  VPBUFFER_CONS(alphaMonBuffer), ALP_Sig_MonitorRX, 5 },
  [ALP_Link_ALinkTX] = { 2, AL_BITRATE, LINK_MODE_TX,
			 VPBUFFER_CONS(alphaTxBuffer), ALP_Sig_AlphaTX },
  [ALP_Link_HostRX] = { 3, 115200, LINK_MODE_RXTX,
			VPBUFFER_CONS(hostRxBuffer), ALP_Sig_HostRX, 5 },
  [ALP_Link_HostTX] = { 3, 115200, LINK_MODE_RXTX,	*/
			
  /*  [ALP_Link_ALinkMon] = { AL_BITRATE, LINK_MODE_TX,
      VPBUFFER_CONS(alphaMonBuffer), ALP_Sig_MonitorRX, 5000 }, */
			  
  [ALP_Link_HostRX] = { StaP_Txcv_VCP, 115200, LINK_MODE_RXTX,
			VPBUFFER_CONS(hostRxBuffer), ALP_Sig_HostRX, 5000 },
  [ALP_Link_HostTX] = { StaP_Txcv_VCP, 115200, LINK_MODE_RXTX,
			VPBUFFER_CONS_NULL, ALP_Sig_HostTX }, 
  [ALP_Link_ALinkRX] = { StaP_Txcv_UART6, AL_BITRATE, LINK_MODE_RXTX,
			 VPBUFFER_CONS(alphaRxBuffer), ALP_Sig_AlphaRX, 5000 },
  [ALP_Link_ALinkTX] = { StaP_Txcv_UART6, AL_BITRATE, LINK_MODE_RXTX,
			 VPBUFFER_CONS_NULL, ALP_Sig_AlphaTX },
  [ALP_Link_TelemRX] = { StaP_Txcv_UART1, 57600, LINK_MODE_RXTX,
			 VPBUFFER_CONS(telemRxBuffer), ALP_Sig_TelemRX, 5000 },
  [ALP_Link_TelemTX] = { StaP_Txcv_UART1, 57600, LINK_MODE_RXTX,
			 VPBUFFER_CONS_NULL, ALP_Sig_TelemTX },
  [ALP_Link_SRXLInA] =  { StaP_Txcv_UART2, 115200, LINK_MODE_RX,
			  VPBUFFER_CONS(recARxBuffer), ALP_Sig_RX1, 1500 },
  [ALP_Link_SRXLInA_TX] = { StaP_Txcv_UART2, 115200, LINK_MODE_RX,
			    VPBUFFER_CONS_NULL, ALP_Sig_RX1_TX }, 
  [ALP_Link_SRXLInB] = { StaP_Txcv_UART4, 115200, LINK_MODE_RX,
			 VPBUFFER_CONS(recBRxBuffer), ALP_Sig_RX2, 1500 },
  [ALP_Link_SRXLOutA] = { StaP_Txcv_UART3, 57600, LINK_MODE_TX,
			  VPBUFFER_CONS_NULL, ALP_Sig_SRXL1 },
  [ALP_Link_SRXLOutB] = { StaP_Txcv_UART5, 57600, LINK_MODE_TX,
			  VPBUFFER_CONS_NULL, ALP_Sig_SRXL2 }
};

typedef struct {
  const char *name;
  uint8_t stap;
} Context_t;

Context_t context[] = { { "HOST", ALP_Link_HostTX },
			{ "AL", ALP_Link_ALinkTX },
			{ "MONITOR", ALP_Link_ALinkMon },
			{ "TELE", ALP_Link_TelemTX } };

void datagramRxError(void *cp, const char *error, uint16_t code)
{
  Context_t *context = (Context_t*) cp;
  STAP_Error(STAP_ERR_DATAGRAM);
  consoleNotefLn("[%s] %s (%#x)", context->name, error, code);
}
  
void datagramHandlerHost(void *cp, uint8_t node, const uint8_t *data, size_t size)
{
  Context_t *context = (Context_t*) cp;
  uint8_t header = data[0];

  data++;
  size--;
  
  switch(header) {
  case HL_HEARTBEAT:
    //    consoleNoteLn_P(CS_STRING("HEARTBEAT"));

    if(context->stap == ALP_Link_HostTX && !vpStatus.consoleLink) {
      vpStatus.consoleLink = true;
      consoleNoteLn_P(CS_STRING("Console CONNECTED"));
    }
    break;
    
  case HL_CONSOLE:
    if(context->stap == ALP_Link_HostTX)
      executeCommand((char*) data);
    break;

  case HL_SIMLINK:
    if(context->stap == ALP_Link_HostTX
       && vpStatus.consoleLink && size == sizeof(sensorData)) {
      if(!vpStatus.simulatorLink) {
	consoleNoteLn_P(CS_STRING("Simulator CONNECTED"));
	vpStatus.simulatorLink = true;
      }

      memcpy(&sensorData, data, sizeof(sensorData));
      simTimeStamp = vpTimeSecsApprox;
      simFrames++;
    }
    break;

  case HL_PING:
    break;

  default:
    datagramRxError(cp, "FUNNY", header);
  }
}

void datagramHandlerAlphaMonitor(void *context, uint8_t node, const uint8_t *data, size_t size)
{
  
}

void datagramHandlerTelem(void *context, uint8_t node, const uint8_t *data, size_t size)
{
  
}

void datagramHandlerAlpha(void *context, uint8_t node, const uint8_t *data, size_t size)
{
  if(size < 1)
    return;
  
  switch(data[0]) {
  case AL_RESPONSE:
    sensorDataReceive(node & ~1, node & 1, &data[1], size - 1);
    break;

  case AL_DEBUG:
    consolePrint("\033[7m");
    consoleOut(&data[1], size - 1);
    consolePrint("\033[0m");
    break;

  default:
    consolePrintfLn("Illegal AL action %d", data[0]);
    break;
  }
}

void dgLinkTxBegin(void *cp)
{
  Context_t *context = (Context_t*) cp;
  if(context->stap != ALP_Link_HostTX || vpStatus.consoleLink)
    STAP_LinkTalk(context->stap);
}

void dgLinkTxEnd(void *cp)
{
  Context_t *context = (Context_t*) cp;
  if(context->stap != ALP_Link_HostTX || vpStatus.consoleLink)
    STAP_LinkListen(context->stap, TX_TIMEOUT);
}

void dgLinkOut(void *cp, const uint8_t *b, size_t l)
{
  Context_t *context = (Context_t*) cp;
  if(context->stap != ALP_Link_HostTX || vpStatus.consoleLink) {
    STAP_LinkPut(context->stap, (const char*) b, l, TX_TIMEOUT);
  }
}

//
// Setup and main loop
//

void mainLoopSetup()
{
  // Datagram links
  
  datagramLinkInit(&hostLink, 0,
		   datagramRxStoreHost, sizeof(datagramRxStoreHost),
		   (void*) &context[0],
		   datagramHandlerHost,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);

  consoleLink = &hostLink;
  
  datagramLinkInit(&alphaLink, 0,
		   datagramRxStoreAlphaLink, sizeof(datagramRxStoreAlphaLink),
		   (void*) &context[1],
		   datagramHandlerAlpha,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);
  
  alphaLink.minInterDelay = 4;
  
  datagramLinkInit(&alphaLinkMonitor, 0,
		   datagramRxStoreAlphaLinkMonitor, sizeof(datagramRxStoreAlphaLinkMonitor),
		   (void*) &context[2],
		   datagramHandlerAlphaMonitor,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);

  datagramLinkInit(&telemLink, 0,
		   datagramRxStoreTelemLink, sizeof(datagramRxStoreTelemLink),
		   (void*) &context[3],
		   datagramHandlerTelem,
		   datagramRxError,
		   dgLinkOut,
		   dgLinkTxBegin,
		   dgLinkTxEnd);
  
  // Initial gear state is DOWN
  
  vpControl.gearSel = 0;
  vpMode.gearSelected = false;

  // Initialization task state

  vpControl.initState = it_init;

  gaugeVariable[0] = 0;
  gaugeCount = 1;
}

